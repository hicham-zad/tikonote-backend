import { YoutubeTranscript } from '@danielxceron/youtube-transcript';
import { Innertube, UniversalCache } from 'youtubei.js';
import ytdl from '@distube/ytdl-core';
import axios from 'axios';
import { HttpsProxyAgent } from 'https-proxy-agent';
import { google } from 'googleapis';
import {
  TranscriptError,
  TRANSCRIPT_ERRORS,
  detectErrorType,
  ERROR_MESSAGES
} from './youtubeErrors.js';

let youtubeClient = null;

const getYoutubeClient = async () => {
  if (!youtubeClient) {
    const config = {
      cache: new UniversalCache(false),
      generate_session_locally: true,
    };

    if (process.env.YOUTUBE_COOKIES) {
      config.cookie = process.env.YOUTUBE_COOKIES;
    }

    if (process.env.PROXY_URL) {
      config.proxy = {
        url: process.env.PROXY_URL,
      }
    }

    youtubeClient = await Innertube.create(config);
  }
  return youtubeClient;
};

// Helper to parse cookies string "key=value; key2=value2" into array for ytdl
const parseCookies = (cookieStr) => {
  if (!cookieStr) return undefined;
  try {
    return cookieStr.split(';').map(c => {
      const parts = c.split('=');
      const key = parts[0]?.trim();
      const value = parts.slice(1).join('=').trim();
      if (key && value) return { name: key, value };
      return null;
    }).filter(c => c);
  } catch (e) {
    console.warn('Failed to parse cookies:', e);
    return undefined;
  }
};

/**
 * Check video availability and caption status before extraction
 * @param {string} videoId - YouTube video ID
 * @returns {Object} Video availability info
 */
export const checkVideoAvailability = async (videoId) => {
  const result = {
    videoId,
    exists: false,
    isPrivate: false,
    isAgeRestricted: false,
    isLiveStream: false,
    isRegionBlocked: false,
    hasCaptions: false,
    hasAutoCaptions: false,
    hasManualCaptions: false,
    captionLanguages: [],
    title: null,
    duration: null,
    durationSeconds: null,
    error: null,
  };

  try {
    // Try using ytdl-core first (fastest)
    const info = await ytdl.getBasicInfo(`https://www.youtube.com/watch?v=${videoId}`);
    const details = info.videoDetails;
    const playerResponse = info.player_response;

    result.exists = true;
    result.title = details.title;
    result.duration = details.lengthSeconds;
    result.durationSeconds = parseInt(details.lengthSeconds, 10);

    // Check for live stream
    if (details.isLive || details.isLiveContent) {
      result.isLiveStream = true;
    }

    // Check for age restriction
    if (playerResponse?.playabilityStatus?.reason?.includes('age') ||
      details.age_restricted) {
      result.isAgeRestricted = true;
    }

    // Check for captions
    const captions = playerResponse?.captions?.playerCaptionsTracklistRenderer?.captionTracks;
    if (captions && captions.length > 0) {
      result.hasCaptions = true;
      result.captionLanguages = captions.map(c => ({
        code: c.languageCode,
        name: c.name?.simpleText || c.languageCode,
        isAutoGenerated: c.kind === 'asr',
      }));
      result.hasAutoCaptions = captions.some(c => c.kind === 'asr');
      result.hasManualCaptions = captions.some(c => c.kind !== 'asr');
    }

    // Check duration limit (3 hours = 10800 seconds)
    if (result.durationSeconds > 10800) {
      result.error = TRANSCRIPT_ERRORS.VIDEO_TOO_LONG;
    }

  } catch (error) {
    const msg = error.message?.toLowerCase() || '';

    if (msg.includes('private') || msg.includes('sign in')) {
      result.isPrivate = true;
      result.error = TRANSCRIPT_ERRORS.VIDEO_PRIVATE;
    } else if (msg.includes('age') || msg.includes('confirm')) {
      result.isAgeRestricted = true;
      result.error = TRANSCRIPT_ERRORS.VIDEO_AGE_RESTRICTED;
    } else if (msg.includes('unavailable') || msg.includes('not found') || msg.includes('does not exist')) {
      result.error = TRANSCRIPT_ERRORS.VIDEO_NOT_FOUND;
    } else if (msg.includes('blocked') || msg.includes('country')) {
      result.isRegionBlocked = true;
      result.error = TRANSCRIPT_ERRORS.REGION_BLOCKED;
    } else {
      // Try YouTube API as backup
      try {
        const apiKey = process.env.YOUTUBE_API_KEY;
        if (apiKey) {
          const youtube = google.youtube({ version: 'v3', auth: apiKey });
          const response = await youtube.videos.list({
            part: ['snippet', 'contentDetails', 'status'],
            id: [videoId],
          });

          if (response.data.items && response.data.items.length > 0) {
            const video = response.data.items[0];
            result.exists = true;
            result.title = video.snippet?.title;

            // Parse duration (ISO 8601)
            const duration = video.contentDetails?.duration;
            if (duration) {
              const match = duration.match(/PT(?:(\d+)H)?(?:(\d+)M)?(?:(\d+)S)?/);
              if (match) {
                const hours = parseInt(match[1] || 0);
                const minutes = parseInt(match[2] || 0);
                const seconds = parseInt(match[3] || 0);
                result.durationSeconds = hours * 3600 + minutes * 60 + seconds;
              }
            }
          } else {
            result.error = TRANSCRIPT_ERRORS.VIDEO_NOT_FOUND;
          }
        }
      } catch (apiError) {
        console.warn('YouTube API fallback failed:', apiError.message);
        result.error = TRANSCRIPT_ERRORS.VIDEO_NOT_FOUND;
      }
    }
  }

  return result;
};

// Strategy 4: YouTube Data API v3
const extractWithYouTubeAPI = async (videoId) => {
  const apiKey = process.env.YOUTUBE_API_KEY;
  if (!apiKey) {
    throw new Error('YOUTUBE_API_KEY not configured');
  }

  console.log('ðŸ”‘ Strategy 4: Attempting YouTube Data API v3...');

  const youtube = google.youtube({ version: 'v3', auth: apiKey });

  // Step 1: Get video details for title
  const videoResponse = await youtube.videos.list({
    part: ['snippet'],
    id: [videoId],
  });

  const videoTitle = videoResponse.data.items?.[0]?.snippet?.title || `YouTube Video ${videoId}`;

  // Step 2: Get caption tracks
  const captionsResponse = await youtube.captions.list({
    part: ['snippet'],
    videoId: videoId,
  });

  const captions = captionsResponse.data.items;
  if (!captions || captions.length === 0) {
    throw new Error('No captions available via YouTube API');
  }

  // Prefer English, otherwise take first available
  const englishCaption = captions.find(c => c.snippet?.language === 'en');
  const caption = englishCaption || captions[0];
  const captionId = caption.id;

  console.log(`ðŸ“ Found caption track: ${caption.snippet?.name || caption.snippet?.language}`);

  // Step 3: Download caption content
  // Note: This requires OAuth for third-party captions, but works for auto-captions
  // For auto-captions, we'll use the timedtext endpoint as fallback
  try {
    const captionResponse = await youtube.captions.download({
      id: captionId,
      tfmt: 'srt', // Get as SRT format
    });

    if (captionResponse.data) {
      // Parse SRT to plain text
      const srtText = captionResponse.data;
      const text = srtText
        .split('\n')
        .filter(line => !line.match(/^\d+$/) && !line.match(/^\d{2}:\d{2}:\d{2}/))
        .join(' ')
        .replace(/\s+/g, ' ')
        .trim();

      console.log('âœ… Strategy 4 success!');
      return {
        text,
        title: videoTitle,
        duration: null,
        videoId,
      };
    }
  } catch (downloadError) {
    console.warn('Direct caption download failed (may need OAuth):', downloadError.message);

    // Fallback: Use timedtext API for auto-generated captions
    const lang = caption.snippet?.language || 'en';
    const timedTextUrl = `https://www.youtube.com/api/timedtext?v=${videoId}&lang=${lang}&fmt=srv3`;

    try {
      const response = await axios.get(timedTextUrl, {
        headers: {
          'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36',
        }
      });

      if (response.data) {
        // Parse XML transcript
        const matches = [...response.data.matchAll(/<text[^>]*>(.*?)<\/text>/g)];
        const text = matches.map(m => {
          return m[1]
            .replace(/&amp;/g, '&')
            .replace(/&lt;/g, '<')
            .replace(/&gt;/g, '>')
            .replace(/&quot;/g, '"')
            .replace(/&#39;/g, "'");
        }).join(' ');

        if (text.length > 0) {
          console.log('âœ… Strategy 4 success (via timedtext fallback)!');
          return {
            text,
            title: videoTitle,
            duration: null,
            videoId,
          };
        }
      }
    } catch (timedTextError) {
      console.warn('Timedtext fallback failed:', timedTextError.message);
    }
  }

  throw new Error('Failed to download captions via YouTube API');
};

export const extractYouTubeTranscript = async (url, options = {}) => {
  const { skipPreflightCheck = false } = options;

  // Extract and validate video ID
  let videoId;
  try {
    videoId = extractVideoId(url);
  } catch (e) {
    throw new TranscriptError(TRANSCRIPT_ERRORS.INVALID_URL, null, { url });
  }

  console.log(`ðŸŽ¥ Attempting to extract transcript for video ID: ${videoId}`);
  console.log(`ðŸ“º Full URL: ${url}`);

  // Pre-flight availability check (optional but recommended)
  if (!skipPreflightCheck) {
    console.log('ðŸ” Running pre-flight availability check...');
    const availability = await checkVideoAvailability(videoId);

    if (availability.error) {
      console.warn(`âŒ Pre-flight check failed: ${availability.error}`);
      throw new TranscriptError(availability.error, null, {
        videoId,
        availability
      });
    }

    if (!availability.hasCaptions) {
      console.warn('âš ï¸ No captions detected for this video');
      // Don't fail yet - strategies might still work with auto-captions
    }

    console.log(`âœ… Pre-flight check passed: ${availability.title || videoId}`);
  }

  // Setup Agents for YTDL
  const proxyUrl = process.env.PROXY_URL;
  const cookies = parseCookies(process.env.YOUTUBE_COOKIES);

  let ytdlAgent;
  try {
    const agentOptions = {};
    if (proxyUrl) {
      console.log('ðŸ”— Using Proxy for YouTube extraction');
      agentOptions.http = new HttpsProxyAgent(proxyUrl);
      agentOptions.https = new HttpsProxyAgent(proxyUrl);
    }

    ytdlAgent = ytdl.createAgent(cookies, agentOptions);
  } catch (e) {
    console.warn('Failed to create YTDL agent:', e);
  }

  // Track errors from each strategy for better diagnostics
  const strategyErrors = [];

  // Strategy 1: Fast Scraper (youtube-transcript)
  try {
    console.log('âš¡ï¸ Strategy 1: Attempting fast scraper...');
    const transcriptData = await YoutubeTranscript.fetchTranscript(videoId);

    if (transcriptData && transcriptData.length > 0) {
      console.log(`âœ… Strategy 1 success! Segments: ${transcriptData.length}`);
      const text = transcriptData.map(segment => segment.text).join(' ');
      return {
        text,
        title: `YouTube Video ${videoId}`,
        duration: null,
        videoId
      };
    }
  } catch (error) {
    console.warn(`âš ï¸ Strategy 1 failed: ${error.message}`);
    strategyErrors.push({ strategy: 1, error: error.message });
  }

  // Strategy 2: Robust Client (Innertube / youtubei.js)
  try {
    console.log('ðŸ›¡ï¸ Strategy 2: Attempting robust client (InnerTube)...');
    const youtube = await getYoutubeClient();
    const info = await youtube.getInfo(videoId);

    let transcriptData;
    try {
      transcriptData = await info.getTranscript();
    } catch (innerErr) {
      console.warn('Primary transcript extraction failed:', innerErr.message);
      if (info.captions) {
        transcriptData = await info.getTranscript();
      }
      if (!transcriptData) throw innerErr;
    }

    if (transcriptData && transcriptData.transcript?.content?.body?.initial_segments) {
      console.log('âœ… Strategy 2 success!');
      const segments = transcriptData.transcript.content.body.initial_segments;
      const text = segments.map(segment => segment.snippet.text).join(' ');
      return {
        text,
        title: info.basic_info.title || `YouTube Video ${videoId}`,
        duration: info.basic_info.duration || null,
        videoId,
      };
    }
  } catch (error) {
    console.warn('âŒ Strategy 2 failed:', error.message);
    strategyErrors.push({ strategy: 2, error: error.message });
  }

  // Strategy 3: ytdl-core + XML parsing
  try {
    console.log('ðŸ“¼ Strategy 3: Attempting ytdl-core extraction...');
    const info = await ytdl.getInfo(`https://www.youtube.com/watch?v=${videoId}`, { agent: ytdlAgent });
    const captions = info.player_response?.captions?.playerCaptionsTracklistRenderer?.captionTracks;

    if (captions && captions.length > 0) {
      const track = captions.find(t => t.languageCode === 'en') || captions[0];
      const transcriptUrl = track.baseUrl;

      console.log(`Fetching transcript from: ${transcriptUrl}`);

      let attempts = 0;
      const maxAttempts = 3;
      let xml = null;

      const axiosConfig = {
        headers: {
          'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36',
        }
      };

      if (proxyUrl) {
        const proxyAgent = new HttpsProxyAgent(proxyUrl);
        axiosConfig.httpAgent = proxyAgent;
        axiosConfig.httpsAgent = proxyAgent;
      }

      while (attempts < maxAttempts) {
        try {
          const response = await axios.get(transcriptUrl, axiosConfig);
          xml = response.data;
          break;
        } catch (err) {
          attempts++;
          console.warn(`Attempt ${attempts} failed: ${err.message}`);
          if (attempts >= maxAttempts) throw err;
          await new Promise(r => setTimeout(r, 1500 * attempts));
        }
      }

      const cleanText = (str) => {
        return str
          .replace(/&amp;/g, '&')
          .replace(/&lt;/g, '<')
          .replace(/&gt;/g, '>')
          .replace(/&quot;/g, '"')
          .replace(/&#39;/g, "'");
      };

      if (xml) {
        const matches = [...xml.matchAll(/<text[^>]*>(.*?)<\/text>/g)];
        const text = matches.map(m => cleanText(m[1])).join(' ');

        if (text.length > 0) {
          console.log('âœ… Strategy 3 success!');
          return {
            text,
            title: info.videoDetails.title || `YouTube Video ${videoId}`,
            duration: info.videoDetails.lengthSeconds,
            videoId,
          };
        }
      }
    }
    throw new Error('No captions found via ytdl-core');
  } catch (error) {
    console.warn('âŒ Strategy 3 failed:', error.message);
    strategyErrors.push({ strategy: 3, error: error.message });
  }

  // Strategy 4: YouTube Data API v3 (Official)
  try {
    return await extractWithYouTubeAPI(videoId);
  } catch (error) {
    console.warn('âŒ Strategy 4 failed:', error.message);
    strategyErrors.push({ strategy: 4, error: error.message });
  }

  // All strategies failed - determine the most likely cause
  console.error('âŒ All extraction strategies failed:', strategyErrors);

  // Check if any error indicates no captions
  const noCaptionsError = strategyErrors.find(e =>
    e.error?.toLowerCase().includes('caption') ||
    e.error?.toLowerCase().includes('subtitle') ||
    e.error?.toLowerCase().includes('transcript')
  );

  if (noCaptionsError) {
    throw new TranscriptError(
      TRANSCRIPT_ERRORS.NO_CAPTIONS_AVAILABLE,
      null,
      { videoId, strategies: strategyErrors }
    );
  }

  // Default to extraction failed
  throw new TranscriptError(
    TRANSCRIPT_ERRORS.EXTRACTION_FAILED,
    'All extraction strategies failed. The video may have captions disabled or be temporarily unavailable.',
    { videoId, strategies: strategyErrors }
  );
};

// Helper to extract video ID from various YouTube URL formats
export const extractVideoId = (url) => {
  const patterns = [
    /(?:youtube\.com\/watch\?v=|youtu\.be\/)([^&\n?#]+)/,
    /youtube\.com\/embed\/([^&\n?#]+)/,
    /youtube\.com\/shorts\/([^&\n?#]+)/,
  ];

  for (const pattern of patterns) {
    const match = url.match(pattern);
    if (match) return match[1];
  }

  throw new TranscriptError(TRANSCRIPT_ERRORS.INVALID_URL, null, { url });
};